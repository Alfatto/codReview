public class Traffic {
	/**
	 * Оптимизация беспилотного трафика
	 * Яндекс выпускает на улицы тысячи беспилотных автомобилей, и теперь появляется отличная возможность оптимизации трафика на дорогах. Прежде всего требуется точно оценить время прибытия машины в место назначения.
	 *
	 * На дороге автомобиль постоянно встречает светофоры, которые горят либо зелёным, либо красным. Время горения зелёного и красного света задаётся в секундах. Цикл переключения цветов повторяется бесконечно и начинается с красного цвета.
	 *
	 * Так как скорость автомобиля известна, положения светофоров на дороге определяются временем, которое требуется, чтобы доехать до этого светофора из начала дороги при условии, что все предыдущие светофоры горят зелёным.
	 *
	 * Каждый светофор также характеризуется временем горения красного и зелёного цвета.
	 *
	 * Задача -- определить, за какое время автомобиль доберётся до конца дороги.
	 *
	 * Например, имеется дорога длиной 10 единиц времени. Первый светофор расположен на отметке 3 единицы времени и характеризуется циклом 5 красный 5 зелёный. Второй светофор расположен на отметке 5, и время показа красного и зелёного для него 2 и 2.
	 *
	 * Автомобиль стартует, через 3 единицы добирается до первого светофора, на котором горит красный. Он горит 5 единиц, то есть движение начинается с 5-го момента.
	 *
	 * Через две единицы автомобиль добирается до второго светофора -- это абсолютный момент 7. В этот момент на светофоре горит зелёный, и автомобиль проезжает его без остановки. От второго светофора до конца дороги остаётся ещё 5 моментов, таким образом суммарное время автомобиля в пути равно 12 (7 + 5).
	 *
	 * Функция
	 *
	 * int Unmanned(int L, int N, int [][3] track)
	 * получает на вход длину L дороги, количество светофоров на ней N, и описание самой дороги, где каждый элемент состоит из трёх значений: момент времени относительно начала дороги (когда в него прибудет автомобиль по свободной дороге), время показа красного света и время показа зелёного цвета.
	 * Для примера выше параметры функции Unmanned() будут такими: 10, 2, [ [3,5,5], [5,2,2] ]
	 *
	 * Функция возвращает реальное время, требуемое для преодоления дороги.
	 * @param args
	 */
	public static void main(String[] args) {
		//для теста
		//Unmanned(10, 2, [[11,5,5],[15,2,2]]) = 10
		//Unmanned(10, 2, [[3,5,5],[5,2,2]]) = 12
		//Unmanned(10, 2, [[3,6,2],[6,2,2]]) = 14

		int[][] n = {{3,6,2},{6,2,2}};
		int[][] nn = {{3,5,5},{5,2,2}};
		int[][] nnn = {{11,5,5},{15,2,2}};


		System.out.println("прошло: " + Unmanned(10, 2, nn));
		System.out.println();

	}
	public static int Unmanned(int L, int N, int [][] track) {
		//общее время между пунктами(светофорами и концом пути)
		int timeBetWeenPoints = 0;
		int result = 0;
		int trafficLight = 0;
		//время светофора
		int totalTrafficLightTime = 0;
		//свет светофора
		boolean red = true;
		//секунды красного светофора
		int secondsOfRed = 0;
		int sumTimeRed = 0;

		if (L <= track[0][0]) {
			return L;
		}

		//идем циклом по светофорам
		for (int i = 0; i < N; i++) {
			if (i == 0) {
				timeBetWeenPoints += track[trafficLight][0];
			} else if (trafficLight <= N - 1 && track[trafficLight][0] <= L) {
				//вычисляем время между светофорами кроме последнего участка
				timeBetWeenPoints += track[trafficLight][0] - track[trafficLight - 1][0];
			}
			//вычисляем свет светофора
			for (int k = 0; k <= timeBetWeenPoints; k++) {
				//добавляем секунды светофора
				if (red) {
					totalTrafficLightTime += track[trafficLight][1];
					red = false;
					k += track[trafficLight][1];
				} else {
					totalTrafficLightTime += track[trafficLight][2];
					red = true;
					k +=  track[trafficLight][2];
				}
				//если секунды больше или равно time
				if (totalTrafficLightTime >= timeBetWeenPoints && red) red = false;
				else if (totalTrafficLightTime >= timeBetWeenPoints) red = true;

			}
			//считаем время красного горения
			if (red) {
				secondsOfRed += Math.abs(timeBetWeenPoints - totalTrafficLightTime);
				sumTimeRed += secondsOfRed;
				secondsOfRed = 0;

			}
			totalTrafficLightTime = 0;

			if (timeBetWeenPoints < L && trafficLight == N - 1 || track[trafficLight][0] > L) {
				//вариант когда от последнего светофора до конца пути еще есть время
				sumTimeRed += L - timeBetWeenPoints;
			}
			timeBetWeenPoints += sumTimeRed;
			trafficLight++;
		}
		result += timeBetWeenPoints;
		return  result;
	}

}
